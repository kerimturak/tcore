{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"The RISC-V Instruction Set Manual","text":""},{"location":"#volume-ii-privileged-architecture","title":"Volume II: Privileged Architecture","text":""},{"location":"#document-version-20211203","title":"Document Version 20211203","text":""},{"location":"#preface","title":"Preface","text":"<p>Bu d\u00f6k\u00fcmanda RISC-V Privelege mimarisi a\u00e7\u0131klanm\u0131\u015ft\u0131r. Versiyon : 20211203 A\u015fa\u011f\u0131daki RISC-V ISA mod\u00fcllerini i\u00e7erir</p> <p></p>"},{"location":"#degisiklikler-ksm-cevrilmedi","title":"De\u011fi\u015fiklikler k\u0131sm\u0131 \u00e7evrilmedi","text":"<p>Added optional big-endian and bi-endian support. Made priority of load/store/AMO address-misaligned exceptions implementation-defined relative to load/store/AMO page-fault and access-fault exceptions. PMP reset values are now platform-defined.  An additional 48 optional PMP registers have been defined.  Slightly relaxed the atomicity requirement for A and D bit updates performed by the implementation.  Clarify the architectural behavior of address-translation caches.  Added Sv57 and Sv57x4 address translation modes.  Clarified that bare S-mode need not support the SFENCE.VMA instruction. Specified relaxed constraints for implicit reads of non-idempotent regions. Added the Svnapot Standard Extension, along with the N bit in Sv39, Sv48, and Sv57 PTEs Added the Svpbmt Standard Extension, along with the PBMT bits in Sv39, Sv48, and Sv57 PTEs. Added the Svinval Standard Extension and associated instructions. Finally, the hypervisor architecture proposal has been extensively revised.</p>"},{"location":"#preface-to-version-111","title":"Preface to Version 1.11","text":"<p>This is version 1.11 of the RISC-V privileged architecture. The document contains the following versions of the RISC-V ISA modules:  versityon 1.10 \u00fczerinde yap\u0131lan de\u011fi\u015fikler - The virtual-memory system no longer permits supervisor mode to execute instructions from user pages, regardless of the SUM setting. - Clarified that ASIDs are private to a hart, and added commentary about the possibility of a future global-ASID extension. - SFENCE.VMA semantics have been clarified. - Required all harts in a system to employ the same PTE-update scheme as each other - Described scheme for emulating misaligned AMOs. - Specified the behavior of the misa and xepc registers in systems with variable IALIGN. -  Specified semantics for PMP regions coarser than four bytes.</p>"},{"location":"#chapter-1","title":"Chapter 1","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Bu d\u00f6k\u00fcman RISC-V privelege mimarisini a\u00e7\u0131klar. Unprivlege modun yan\u0131 s\u0131ra operating system \u00e7al\u0131\u015ft\u0131rmak ve harici cihazlarla ba\u011flant\u0131 sa\u011flamak i\u00e7in ekstra fonsiyonelliklerin eklenmesi gerekmektedir.</p>"},{"location":"#11-risc-v-privileged-software-stack-terminology","title":"1.1 RISC-V Privileged Software Stack Terminology","text":"<p>Note</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Pied Piper</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Subscribe to our newsletter</p> <pre><code>`timescale 1ns/ 100 ps\n\nmodule FIFO_v #(parameter ADDR_W = 4, DATA_W = 24, BUFF_L = 16, ALMST_F = 3, ALMST_E = 3)   // buffer length must be less than or equal to address space as in  BUFF_L &lt;or= 2^(ADDR_W)-1\n            (\n            output reg      [DATA_W- 1  :   0]              data_out,\n            output reg      [ADDR_W     :   0]              data_count,\n            output  reg                                                         empty,\n            output  reg                                                         full,\n            output  reg                                                         almst_empty,\n            output  reg                                                         almst_full,\n            output  reg                                                         err,\n            input       wire    [DATA_W -1  :   0]              data_in,\n            input       wire                                                        wr_en,\n            input       wire                                                        rd_en,\n            input       wire                                                        n_reset,\n            input       wire                                                        clk\n            );\n\n\n////--------------- internal variables ---------------------------------------------------------            \n\n            reg                 [DATA_W-1 : 0]  mem_array [0 : (2**ADDR_W)-1];\n            reg                 [ADDR_W-1 : 0]  rd_ptr, wr_ptr;\n            reg                 [ADDR_W-1 : 0]  rd_ptr_nxt, wr_ptr_nxt;\n            reg                                                     full_ff, empty_ff;\n            reg                                                     full_ff_nxt, empty_ff_nxt;\n            reg                                                     almst_f_ff, almst_e_ff;\n            reg                                                     almst_f_ff_nxt, almst_e_ff_nxt;\n            reg                 [ADDR_W : 0]        q_reg, q_nxt;\n            reg                                                     q_add, q_sub;\n//// ------------------------------------------------------------------------------------------------\n\n\n//// Always block to update the states\n//// ------------------------------------------------------------------------------------------------\n    always @ (posedge clk)\n        begin   :   reg_update\n            if(n_reset == 1'b 0)\n                begin\n                    rd_ptr &lt;= {(ADDR_W-1){1'b 0}};\n                    wr_ptr &lt;= {(ADDR_W-1){1'b 0}};\n                    full_ff &lt;= 1'b 0;\n                    empty_ff &lt;= 1'b 1;\n                    almst_f_ff &lt;= 1'b 0;\n                    almst_e_ff &lt;= 1'b 1;\n                    q_reg &lt;= {(ADDR_W){1'b 0}};\n                end\n            else\n                begin\n                    rd_ptr &lt;= rd_ptr_nxt;\n                    wr_ptr &lt;= wr_ptr_nxt;\n                    full_ff &lt;= full_ff_nxt;\n                    empty_ff &lt;= empty_ff_nxt;\n                    almst_f_ff &lt;= almst_f_ff_nxt;\n                    almst_e_ff &lt;= almst_e_ff_nxt;\n                    q_reg &lt;= q_nxt;\n                 end\n        end // end of always\n\n//// Control for almost full and almost emptly flags\n//// ------------------------------------------------------------------------------------------------\n    always @ ( almst_e_ff, almst_f_ff, q_reg)\n        begin   :   Wtr_Mrk_Cont\n            almst_e_ff_nxt = almst_e_ff;\n            almst_f_ff_nxt = almst_f_ff;                \n           //// check to see if wr_ptr is ALMST_E away from rd_ptr (aka almost empty)           \n            if(q_reg &lt; ALMST_E)\n                almst_e_ff_nxt = 1'b 1;\n            else\n                almst_e_ff_nxt = 1'b 0;\n\n            if(q_reg &gt; BUFF_L-ALMST_F)\n                almst_f_ff_nxt = 1'b 1;\n            else\n                almst_f_ff_nxt = 1'b 0;\n\n        end // end of always\n\n//// Control for read and write pointers and empty/full flip flops          \n    always @ (wr_en, rd_en, wr_ptr, rd_ptr, empty_ff, full_ff, q_reg)\n        begin\n\n            wr_ptr_nxt = wr_ptr ;                                           //// no change to pointers\n            rd_ptr_nxt = rd_ptr;\n            full_ff_nxt = full_ff;\n            empty_ff_nxt = empty_ff;\n            q_add = 1'b 0;\n            q_sub = 1'b 0;\n        ////---------- check if fifo is full during a write attempt, after a write increment counter\n        ////----------------------------------------------------            \n            if(wr_en == 1'b 1 &amp; rd_en == 1'b 0)\n                begin\n                    if(full_ff == 1'b 0)\n                        begin\n                            if(wr_ptr &lt; BUFF_L-1)                                   \n                                begin\n                                    q_add = 1'b 1;\n                                    wr_ptr_nxt = wr_ptr + 1;\n                                    empty_ff_nxt = 1'b 0;\n                                end\n                            else\n                                begin\n                                    wr_ptr_nxt = {(ADDR_W-1){1'b 0}};\n                                    empty_ff_nxt = 1'b 0;\n                                end\n                            //// check if fifo is full\n                            if( (wr_ptr+1 == rd_ptr) || ((wr_ptr == BUFF_L-1) &amp;&amp; (rd_ptr == 1'b 0)))   \n                                full_ff_nxt = 1'b 1;\n                        end\n                end\n\n        ////---------- check to see if fifo is empty during a read attempt, after a read decrement counter\n        ////---------------------------------------------------------------\n            if( (wr_en == 1'b 0) &amp;&amp; (rd_en == 1'b 1))\n                begin                   \n                    if(empty_ff == 1'b 0) \n                        begin\n                            if(rd_ptr &lt; BUFF_L-1 )                                                  \n                                begin\n                                    if(q_reg &gt; 0)\n                                        q_sub = 1'b 1;\n                                    else\n                                        q_sub = 1'b 0;\n                                    rd_ptr_nxt = rd_ptr + 1;\n                                    full_ff_nxt = 1'b 0;\n                                end\n                            else    \n                                begin\n                                    rd_ptr_nxt = {(ADDR_W-1){1'b 0}}; \n                                    full_ff_nxt = 1'b 0;        \n                                end\n\n                            //// check if fifo is empty\n                            if( (rd_ptr  + 1 == wr_ptr) || ((rd_ptr == BUFF_L -1) &amp;&amp; (wr_ptr == 1'b 0 )))  \n                                empty_ff_nxt = 1'b 1;\n                        end\n                end\n\n        //// -----------------------------------------------------------------\n            if( (wr_en == 1'b 1) &amp;&amp; (rd_en == 1'b 1)) \n                begin\n                    if(wr_ptr &lt; BUFF_L -1) \n                        wr_ptr_nxt = wr_ptr  + 1;   \n                    else                                            \n                        wr_ptr_nxt =  {(ADDR_W-1){1'b 0}}; \n\n                    if(rd_ptr &lt; BUFF_L -1) \n                        rd_ptr_nxt = rd_ptr + 1;        \n                    else\n                        rd_ptr_nxt = {(ADDR_W-1){1'b 0}}; \n                end\n\n        end  // end of always\n\n\n//// Control for memory array writing and reading\n//// ----------------------------------------------------------------------\n    always @ (posedge clk)\n        begin       :       mem_cont\n            if( n_reset == 1'b 0)\n                begin\n                    mem_array[rd_ptr] &lt;=  {(DATA_W-1){1'b 0}}; \n                    data_out &lt;= {(DATA_W-1){1'b 0}}; \n                    err &lt;= 1'b 0;\n                end\n            else\n                begin\n                    ////  if write enable and not full then latch in data and increment wright pointer  \n                    if( (wr_en == 1'b 1) &amp;&amp; (full_ff == 1'b 0) )\n                        begin\n                            mem_array[wr_ptr] &lt;=  data_in;\n                            err &lt;= 1'b 0;                       \n                        end\n                    else if( (wr_en == 1'b 1) &amp;&amp; (full_ff == 1'b 1))      ////  check if full and trying to write\n                        err &lt;= 1'b 1;\n\n                    //// if read enable and fifo not empty then latch data out and increment read pointer\n                    if( (rd_en == 1'b 1) &amp;&amp; (empty_ff == 1'b 0))\n                        begin\n                            data_out &lt;= mem_array[rd_ptr];\n                            err &lt;= 1'b 0;\n                        end\n                    else if( (rd_en == 1'b 1) &amp;&amp; (empty_ff == 1'b 1))\n                        err &lt;= 1'b 1;\n\n                end // end else\n        end // end always\n\n\n//// Combo Counter with Control Flags\n//// ------------------------------------------------------------------------------------------------\n    always @ ( q_sub, q_add, q_reg)\n        begin   :   Counter\n            case( {q_sub , q_add} )\n                2'b 01 :\n                        q_nxt = q_reg + 1;\n                2'b 10 :\n                        q_nxt = q_reg - 1;\n                default :\n                        q_nxt = q_reg;\n            endcase     \n        end // end of always        \n\n//// Connect internal regs to ouput ports\n//// ------------------------------------------------------------------------------------------------\n    always @ (full_ff, empty_ff, almst_e_ff, almst_f_ff, q_reg)\n        begin\n            full = full_ff;\n            empty = empty_ff;\n            almst_empty = almst_e_ff; \n            almst_full = almst_f_ff;\n            data_count = q_reg;\n        end\n\nendmodule\n\n\n</code></pre> <ol> <li> I'm a code annotation! I can contain <code>code</code>, formatted     text, images, ... basically anything that can be written in Markdown.</li> </ol> <pre><code>graph LR\n  A[Start] --&gt; B{Error?};\n  B --&gt;|Yes| C[Hmm...];\n  C --&gt; D[Debug];\n  D --&gt; B;\n  B ----&gt;|No| E[Yay!];\n</code></pre> <p>Text can be {--deleted--} and replacement text {++added++}. This can also be combined into {one~&gt;a single} operation. {Highlighting} is also possible {&gt;&gt;and comments can be added inline&lt;&lt;}.</p> <p>{==</p> <p>Formatting can also be applied to blocks by putting the opening and closing tags on separate lines and adding new lines between the tags and the content.</p> <p>==}</p> <ul> <li> <p> Set up in 5 minutes</p> <p>Install <code>mkdocs-material</code> with <code>pip</code> and get up and running in minutes</p> <p> Getting started</p> </li> <li> <p> It's just Markdown</p> <p>Focus on your content and generate a responsive and searchable static site</p> <p> Reference</p> </li> <li> <p> Made to measure</p> <p>Change the colors, fonts, language, icons, logo and more with a few lines</p> <p> Customization</p> </li> <li> <p> Open Source, MIT</p> <p>Material for MkDocs is licensed under MIT and available on [GitHub]</p> <p> License</p> </li> </ul> <p></p> \\[ \\operatorname{ker} f=\\{g\\in G:f(g)=e_{H}\\}{\\mbox{.}} \\]"},{"location":"alu/division/","title":"Division","text":"<p>merhaba</p>"},{"location":"alu/multiplication/","title":"Multiplication","text":"<p>We can design a multiplier with two ways one of them is combinational which has better performance but required more chip area, and other one is sequential which gain its power reuse the hardware again and again in process and can be reach high clock frequency with the help of pipeline.</p>"},{"location":"alu/multiplication/#sequential-multiplier","title":"Sequential Multiplier","text":"<p>Lets we think about long multiplication in binary. - Sequential binary multiplication of 10111 and 10011:</p> <pre><code>        00010111 --&gt; multiplicand\n    x   00010011 --&gt; multiplier\n    _________________\n        00000000\n         00000000\n          00000000\n           00010111\n            00000000\n             00000000\n              00010111\n    +          00010111\n    _________________\n           000110110101 --&gt; product\n</code></pre> <p>As usual, we can start multiplication from left to right, but in binary we can use rigth to left as an alternative because there is no carry in this state.</p> <p>We need to multiply this two number and every bits of second number should be multiplied and their shifted state will summed as a result.</p> <p>But this method behave like unsigned operation. Therefor we need to determine sign of operation and then we need to make some extra step to complete.</p> <p>1- First step is determine the resulting product sign.</p> <pre><code>assign sign = A[XLEN-1] ^ B[XLEN-1];\n</code></pre> <p>2- Second step will be take absolute value of operant to obtain proper result in binary.</p> <p>Lets we have -5</p> <p>binary representation :</p> <p><code>-5:  11011</code></p> <p>Two's complement gives absolute (corresponding positive) number in sort.    <code>|-5| : 00100 (not equal still)</code> Then add 1 to it</p> <p><code>|-5| : 00100 + 00001 = 00101</code></p> <p>3 - Now multiply two number using algorithm.</p> <pre><code>a. First thing if you multiply two 32 bit value you obtain at most a 64-bit number. It means you need 32 bit two operant and 64 bit product output.\n\nb. While multiplying every bit of the second number with first number we need to count how many bit is multiplied to ensure when process will end. So there shoul be an counter for this.\n\nc. To iterate on second number bits simply we can shift number.\n\nd.\n    - First operant is called multiplicand\n    - Second operant is called multiplier\n\ne. There should be multiplier register to hold value of B.\n    - We also use this register to hold shifted value to optimize total number of register used in design.\n\nf. Lastly, we need a product register to hold the result of every cycle until final result will obtained.\n\ng. When counter shows last bit is iterated process will done.\n\nThe core code of operation is done in two important code block below\n</code></pre> <pre><code>mult    &lt;= mult &lt;&lt; 1;   // shift one bit mult in every cycle to iterate its most significant bit previous index\nprod    &lt;= (prod + (A &amp; {SIZE{mult[SIZE-1]}})) &lt;&lt; shift; // multiply in one bit number with n bit A same operation with logical AND. If coming bit mult is one so copy A to new block of summution operation by shifting it in every block place. In case of bit mult is zero is equalt logical AND 0 whole number(result will zero array).\n</code></pre> <p>instead of this code block as I mentioned earlier we can use rigth shift to get rid of mul register and reduce the addition operation to 32 bit from 64 bit.</p> <pre><code>/*\nex\n    A = 3'b010  = 2   Multiplicand\n    B = 3'b101  = 5   Multiplier\n  X------------\n           010\n          000\n         010\n  +------------\n         01010   = 10 Product\n\n  0 =&gt; place 0      (0 x multiplicand)\n  1 =&gt; place a copy (1 x multiplicand)\n\n\n\n010 101 start\n\n010 + (010 &amp; 111) = 100\nprod   = 100 101\nshift0 = 010 010\n\n010 + (010 &amp; 000) = 010\nprod   = 010 010\nshift1 = 001 001\n\n001 + (010 &amp; 111) = 011\nprod   = 011 001\nshift2 = 001 100 = 10\n\n\n*/\n</code></pre>"},{"location":"git/git/","title":"Git  Serftifica Tan\u0131mlamas\u0131","text":"<pre><code>$ git config --global http.sslCAInfo sertifika_ad\u0131\n</code></pre>"},{"location":"git/git/#ssh-key-baglants","title":"SSH Key Ba\u011flant\u0131s\u0131","text":"<pre><code>ssh-keygen -t ed25519\n</code></pre> <p>\u00e7\u0131kan se\u00e7enekleri bo\u015f b\u0131rak enter tu\u015funa basarak</p> <p>a\u00e7\u0131k anahtar\u0131n\u0131 a\u015fa\u011f\u0131daki komut ile g\u00f6r </p> <pre><code>cat .ssh/id_ed25519.pub\n</code></pre> <p>git kullan\u0131c\u0131 profili yan\u0131ndaki ayarlardan ssh key k\u0131sm\u0131na girip \u00e7\u0131kan anahtar\u0131 yap\u0131\u015f\u0131t\u0131rp ekleyin.</p>"}]}